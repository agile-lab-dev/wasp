// Code generated by openapi-cli-generator. DO NOT EDIT.
// See https://github.com/danielgtaylor/openapi-cli-generator

package main

import (
	"fmt"
	"strings"

	"github.com/danielgtaylor/openapi-cli-generator/cli"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gopkg.in/h2non/gentleman.v2"
)

var waspOpenapiSubcommand bool

func waspOpenapiServers() []map[string]string {
	return []map[string]string{

		map[string]string{
			"description": "default development server, beware of CORS",
			"url":         "http://localhost:2891",
		},
	}
}

// WaspOpenapiListBatchJob list-batch-job
func WaspOpenapiListBatchJob(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-batch-job"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertBatchJob insert-batch-job
func WaspOpenapiInsertBatchJob(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insert-batch-job"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdateBatchJob update-batch-job
func WaspOpenapiUpdateBatchJob(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "update-batch-job"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeleteBatchJob delete-batch-job
func WaspOpenapiDeleteBatchJob(paramBatchjobname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "delete-batch-job"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListBatchJobInstance list-batch-job-instance
func WaspOpenapiListBatchJobInstance(paramBatchjobname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-batch-job-instance"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}/instances"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetBatchJobInstance get-batch-job-instance
func WaspOpenapiGetBatchJobInstance(paramBatchjobname string, paramInstance string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-batch-job-instance"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}/instances/{instance}"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)
	url = strings.Replace(url, "{instance}", paramInstance, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStartBatchJob start-batch-job
func WaspOpenapiStartBatchJob(paramBatchjobname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "start-batch-job"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/batchjobs/{batchjobname}/start"
	url = strings.Replace(url, "{batchjobname}", paramBatchjobname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetElasticConfig get-elastic-config
func WaspOpenapiGetElasticConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-elastic-config"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/es"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetKafkaConfig get-kafka-config
func WaspOpenapiGetKafkaConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-kafka-config"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/kafka"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetSolrConfig get-solr-config
func WaspOpenapiGetSolrConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-solr-config"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/sorl"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetSparkBatchConfig get-spark-batch-config
func WaspOpenapiGetSparkBatchConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-spark-batch-config"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/sparkbatch"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetSparkStreamingConfig get-spark-streaming-config
func WaspOpenapiGetSparkStreamingConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-spark-streaming-config"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/sparkstreaming"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetTelemetryConfig get-telemetry-config
func WaspOpenapiGetTelemetryConfig(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-telemetry-config"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/config/telemetry"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListDocument list-document
func WaspOpenapiListDocument(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-document"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/documents"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetDocument get-document
func WaspOpenapiGetDocument(paramDocumentname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-document"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/documents/{documentname}"
	url = strings.Replace(url, "{documentname}", paramDocumentname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiCommitProcessgroup commit-processgroup
func WaspOpenapiCommitProcessgroup(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "commit-processgroup"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/editor/nifi/registry/{processGroupId}"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}
	paramProcessgroupid := params.GetString("processgroupid")
	if paramProcessgroupid != "" {
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiNewEditor new-editor
func WaspOpenapiNewEditor(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "new-editor"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/editor/nifi/{processGroupName}"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}
	paramProcessgroupname := params.GetString("processgroupname")
	if paramProcessgroupname != "" {
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiPostPipegraph post-pipegraph
func WaspOpenapiPostPipegraph(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "post-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/editor/pipegraph"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiEvents events
func WaspOpenapiEvents(paramSearch string, paramStarttimestamp string, paramEndtimestamp string, paramPage string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "events"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/events"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("search", paramSearch)

	req = req.AddQuery("startTimestamp", paramStarttimestamp)

	req = req.AddQuery("endTimestamp", paramEndtimestamp)

	req = req.AddQuery("page", paramPage)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListFreeCode list-freeCode
func WaspOpenapiListFreeCode(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-freecode"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/freeCode"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertFreeCode insert-freeCode
func WaspOpenapiInsertFreeCode(params *viper.Viper, body string) (*gentleman.Response, interface{}, error) {
	handlerPath := "insert-freecode"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/freeCode"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// WaspOpenapiCompleteFreeCode complete-freeCode
func WaspOpenapiCompleteFreeCode(paramPosition string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "complete-freecode"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/freeCode/complete/{position}"
	url = strings.Replace(url, "{position}", paramPosition, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetFreeCode get-freeCode
func WaspOpenapiGetFreeCode(paramModelname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-freecode"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/freeCode/instance/{modelname}"
	url = strings.Replace(url, "{modelname}", paramModelname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiValidateFreeCode validate-freeCode
func WaspOpenapiValidateFreeCode(params *viper.Viper, body string) (*gentleman.Response, interface{}, error) {
	handlerPath := "validate-freecode"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/freeCode/validate"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// WaspOpenapiListIndex list-index
func WaspOpenapiListIndex(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-index"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/indexes"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetIndex get-index
func WaspOpenapiGetIndex(paramIndexname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-index"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/indexes/{indexname}"
	url = strings.Replace(url, "{indexname}", paramIndexname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListKeyvalue list-keyvalue
func WaspOpenapiListKeyvalue(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-keyvalue"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/keyvalue"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetKeyvalue get-keyvalue
func WaspOpenapiGetKeyvalue(paramModelname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-keyvalue"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/keyvalue/{modelname}"
	url = strings.Replace(url, "{modelname}", paramModelname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiLogs logs
func WaspOpenapiLogs(paramSearch string, paramStarttimestamp string, paramEndtimestamp string, paramPage string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "logs"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/logs"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("search", paramSearch)

	req = req.AddQuery("startTimestamp", paramStarttimestamp)

	req = req.AddQuery("endTimestamp", paramEndtimestamp)

	req = req.AddQuery("page", paramPage)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListMlmodel list-mlmodel
func WaspOpenapiListMlmodel(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-mlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertMlmodel insert-mlmodel
func WaspOpenapiInsertMlmodel(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insert-mlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdateMlmodel update-mlmodel
func WaspOpenapiUpdateMlmodel(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "update-mlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeleteMlmodel delete-mlmodel
func WaspOpenapiDeleteMlmodel(paramMlmodelname string, paramMlmodelversion string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "delete-mlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels/{mlmodelname}/{mlmodelversion}"
	url = strings.Replace(url, "{mlmodelname}", paramMlmodelname, 1)
	url = strings.Replace(url, "{mlmodelversion}", paramMlmodelversion, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetMlmodel get-mlmodel
func WaspOpenapiGetMlmodel(paramMlmodelname string, paramMlmodelversion string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-mlmodel"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/mlmodels/{mlmodelname}/{mlmodelversion}"
	url = strings.Replace(url, "{mlmodelname}", paramMlmodelname, 1)
	url = strings.Replace(url, "{mlmodelversion}", paramMlmodelversion, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListPipegraph list-pipegraph
func WaspOpenapiListPipegraph(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertPipegraph insert-pipegraph
func WaspOpenapiInsertPipegraph(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insert-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdatePipegraph update-pipegraph
func WaspOpenapiUpdatePipegraph(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "update-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeletePipegraph delete-pipegraph
func WaspOpenapiDeletePipegraph(paramPipegraphname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "delete-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListPipegraphInstance list-pipegraph-instance
func WaspOpenapiListPipegraphInstance(paramPipegraphname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-pipegraph-instance"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/instances"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetPipegraphInstance get-pipegraph-instance
func WaspOpenapiGetPipegraphInstance(paramPipegraphname string, paramInstance string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-pipegraph-instance"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/instances/{instance}"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)
	url = strings.Replace(url, "{instance}", paramInstance, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStartPipegraph start-pipegraph
func WaspOpenapiStartPipegraph(paramPipegraphname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "start-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/start"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStopPipegraph stop-pipegraph
func WaspOpenapiStopPipegraph(paramPipegraphname string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "stop-pipegraph"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/pipegraphs/{pipegraphname}/stop"
	url = strings.Replace(url, "{pipegraphname}", paramPipegraphname, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetProducer get-producer
func WaspOpenapiGetProducer(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-producer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiInsertProducer insert-producer
func WaspOpenapiInsertProducer(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "insert-producer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers"

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiUpdateProducer update-producer
func WaspOpenapiUpdateProducer(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "update-producer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers"

	req := cli.Client.Put().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "text/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiDeleteProducer delete-producer
func WaspOpenapiDeleteProducer(paramProducername string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "delete-producer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers/{producername}"
	url = strings.Replace(url, "{producername}", paramProducername, 1)

	req := cli.Client.Delete().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStartProducer start-producer
func WaspOpenapiStartProducer(paramProducername string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "start-producer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers/{producername}/start"
	url = strings.Replace(url, "{producername}", paramProducername, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStopProducer stop-producer
func WaspOpenapiStopProducer(paramProducername string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "stop-producer"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/producers/{producername}/stop"
	url = strings.Replace(url, "{producername}", paramProducername, 1)

	req := cli.Client.Post().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListRaw list-raw
func WaspOpenapiListRaw(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-raw"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/raw"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetRaw get-raw
func WaspOpenapiGetRaw(paramModelname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-raw"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/raw/{modelname}"
	url = strings.Replace(url, "{modelname}", paramModelname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiStats stats
func WaspOpenapiStats(paramStarttimestamp string, paramEndtimestamp string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "stats"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/stats"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("startTimestamp", paramStarttimestamp)

	req = req.AddQuery("endTimestamp", paramEndtimestamp)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListTelemetryMetric list-telemetry-metric
func WaspOpenapiListTelemetryMetric(paramSearch string, paramSource string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-telemetry-metric"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/telemetry/metrics"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("search", paramSearch)

	req = req.AddQuery("source", paramSource)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetTelemetrySeries get-telemetry-series
func WaspOpenapiGetTelemetrySeries(paramMetric string, paramSource string, paramSize string, paramStarttimestamp string, paramEndtimestamp string, paramAggregate string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-telemetry-series"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/telemetry/series"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("metric", paramMetric)

	req = req.AddQuery("source", paramSource)

	req = req.AddQuery("size", paramSize)

	req = req.AddQuery("startTimestamp", paramStarttimestamp)

	req = req.AddQuery("endTimestamp", paramEndtimestamp)

	req = req.AddQuery("aggregate", paramAggregate)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListTelemetrySource list-telemetry-source
func WaspOpenapiListTelemetrySource(paramSearch string, paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-telemetry-source"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/telemetry/sources"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("search", paramSearch)

	req = req.AddQuery("size", paramSize)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiListTopic list-topic
func WaspOpenapiListTopic(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "list-topic"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/topics"

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// WaspOpenapiGetTopic get-topic
func WaspOpenapiGetTopic(paramTopicname string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "get-topic"
	if waspOpenapiSubcommand {
		handlerPath = "wasp-openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = waspOpenapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/topics/{topicname}"
	url = strings.Replace(url, "{topicname}", paramTopicname, 1)

	req := cli.Client.Get().URL(url)

	paramPretty := params.GetBool("pretty")
	if paramPretty != false {
		req = req.AddQuery("pretty", fmt.Sprintf("%v", paramPretty))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

func waspOpenapiRegister(subcommand bool) {
	root := cli.Root

	if subcommand {
		root = &cobra.Command{
			Use:   "wasp-openapi",
			Short: "wasp-api",
			Long:  cli.Markdown(""),
		}
		waspOpenapiSubcommand = true
	} else {
		cli.Root.Short = "wasp-api"
		cli.Root.Long = cli.Markdown("")
	}

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-batch-job",
			Short:   "list-batch-job",
			Long:    cli.Markdown("Lists all barch jobs"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListBatchJob(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insert-batch-job",
			Short:   "insert-batch-job",
			Long:    cli.Markdown("Inserts a new batch job\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  description:\n    type: string\n  etl:\n    discriminator:\n      propertyName: type\n    oneOf:\n    - $ref: '#/components/schemas/BatchETLModel'\n    - $ref: '#/components/schemas/BatchGdprETLModel'\n  exclusivityConfig:\n    $ref: '#/components/schemas/BatchJobExclusionConfig'\n  name:\n    type: string\n  owner:\n    type: string\n  system:\n    type: boolean\nrequired:\n- name\n- description\n- owner\n- system\n- creationTime\n- etl\n- exclusivityConfig\ntype: object\nxml:\n  name: BatchJobModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertBatchJob(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-batch-job",
			Short:   "update-batch-job",
			Long:    cli.Markdown("Inserts a new batch job\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  description:\n    type: string\n  etl:\n    discriminator:\n      propertyName: type\n    oneOf:\n    - $ref: '#/components/schemas/BatchETLModel'\n    - $ref: '#/components/schemas/BatchGdprETLModel'\n  exclusivityConfig:\n    $ref: '#/components/schemas/BatchJobExclusionConfig'\n  name:\n    type: string\n  owner:\n    type: string\n  system:\n    type: boolean\nrequired:\n- name\n- description\n- owner\n- system\n- creationTime\n- etl\n- exclusivityConfig\ntype: object\nxml:\n  name: BatchJobModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdateBatchJob(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-batch-job batchjobname",
			Short:   "delete-batch-job",
			Long:    cli.Markdown("Deletes a Batch Job"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeleteBatchJob(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-batch-job-instance batchjobname",
			Short:   "list-batch-job-instance",
			Long:    cli.Markdown("Lists all instances of a batch job"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListBatchJobInstance(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-batch-job-instance batchjobname instance",
			Short:   "get-batch-job-instance",
			Long:    cli.Markdown("Get a batch job instance"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetBatchJobInstance(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "start-batch-job batchjobname",
			Short:   "start-batch-job",
			Long:    cli.Markdown("Starts a batch job"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStartBatchJob(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-elastic-config",
			Short:   "get-elastic-config",
			Long:    cli.Markdown("Retrieves the configuration used to connect to elastic"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetElasticConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-kafka-config",
			Short:   "get-kafka-config",
			Long:    cli.Markdown("Retrieves the configuration used to connect to Kafka"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetKafkaConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-solr-config",
			Short:   "get-solr-config",
			Long:    cli.Markdown("Retrieves the configuration used to connect to solr"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetSolrConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-spark-batch-config",
			Short:   "get-spark-batch-config",
			Long:    cli.Markdown("Retrieves the configuration of the Spark Batch context"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetSparkBatchConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-spark-streaming-config",
			Short:   "get-spark-streaming-config",
			Long:    cli.Markdown("Retrieves the configuration of the Spark Streaming context"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetSparkStreamingConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-telemetry-config",
			Short:   "get-telemetry-config",
			Long:    cli.Markdown("Retrieves the configuration of the telemetry subsystem"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetTelemetryConfig(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-document",
			Short:   "list-document",
			Long:    cli.Markdown("Retrieves all models used to write or read from Document Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListDocument(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-document documentname",
			Short:   "get-document",
			Long:    cli.Markdown("Retrieves the model used to write or read from Document Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetDocument(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "commit-processgroup",
			Short:   "commit-processgroup",
			Long:    cli.Markdown("Confirm that a process group edited on a editor instance it's ready to be stored."),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiCommitProcessgroup(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")
		cmd.Flags().String("processgroupid", "", "The process group id to commit")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "new-editor",
			Short:   "new-editor",
			Long:    cli.Markdown("Create a new processGroup on a stateless nifi instance with name processGroupName, returns a processgroupId and the instance url."),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiNewEditor(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")
		cmd.Flags().String("processgroupname", "", "The name of the new processGroup")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "post-pipegraph",
			Short:   "post-pipegraph",
			Long:    cli.Markdown("Pipegraph generation from RawPipegraph\n## Request Schema (text/json)\n\nproperties:\n  description:\n    type: string\n  name:\n    type: string\n  owner:\n    type: string\n  structuredStreamingComponents:\n    items:\n      $ref: '#/components/schemas/StructuredStreamingETLDTO'\n    type: array\nrequired:\n- name\n- description\n- owner\n- structuredStreamingComponents\ntype: object\nxml:\n  name: PipegraphDTO\n  namespace: java://it.agilelab.bigdata.wasp.core.models.editor\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiPostPipegraph(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "events search starttimestamp endtimestamp page size",
			Short:   "events",
			Long:    cli.Markdown("Retrieves events entries"),
			Example: examples,
			Args:    cobra.MinimumNArgs(5),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiEvents(args[0], args[1], args[2], args[3], args[4], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-freecode",
			Short:   "list-freeCode",
			Long:    cli.Markdown("Retrieves the models used to create a free code strategy"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListFreeCode(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insert-freecode",
			Short:   "insert-freeCode",
			Long:    cli.Markdown("Inserts a freeCode model\n## Request Schema (application/json)\n\nproperties:\n  code:\n    type: string\n  name:\n    type: string\nrequired:\n- name\n- code\ntype: object\nxml:\n  name: FreeCodeModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertFreeCode(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "complete-freecode position",
			Short:   "complete-freeCode",
			Long:    cli.Markdown("complete the code of a freeCode model\n## Request Schema (application/json)\n\nproperties:\n  code:\n    type: string\nrequired:\n- code\ntype: object\nxml:\n  name: FreeCode\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiCompleteFreeCode(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-freecode modelname",
			Short:   "get-freeCode",
			Long:    cli.Markdown("Retrieves the models used to create a free code strategy"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetFreeCode(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "validate-freecode",
			Short:   "validate-freeCode",
			Long:    cli.Markdown("Validates a freeCode model\n## Request Schema (application/json)\n\nproperties:\n  code:\n    type: string\nrequired:\n- code\ntype: object\nxml:\n  name: FreeCode\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiValidateFreeCode(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-index",
			Short:   "list-index",
			Long:    cli.Markdown("Retrieve all models used to read or write indexed Data Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListIndex(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-index indexname",
			Short:   "get-index",
			Long:    cli.Markdown("Retrieves all models used to read or write Indexed data stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetIndex(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-keyvalue",
			Short:   "list-keyvalue",
			Long:    cli.Markdown("Retrieves all models used to write or read from KeyValue Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListKeyvalue(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-keyvalue modelname",
			Short:   "get-keyvalue",
			Long:    cli.Markdown("Retrieves the model used to write or read from KeyValue Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetKeyvalue(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "logs search starttimestamp endtimestamp page size",
			Short:   "logs",
			Long:    cli.Markdown("Retrieves logs entries"),
			Example: examples,
			Args:    cobra.MinimumNArgs(5),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiLogs(args[0], args[1], args[2], args[3], args[4], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-mlmodel",
			Short:   "list-mlmodel",
			Long:    cli.Markdown("Retrieve all machine learning models info"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListMlmodel(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insert-mlmodel",
			Short:   "insert-mlmodel",
			Long:    cli.Markdown("Inserts a new MlModel\n## Request Schema (text/json)\n\nproperties:\n  className:\n    nullable: true\n    type: string\n  description:\n    type: string\n  favorite:\n    type: boolean\n  modelFileId:\n    description: Should be a valid mongodb bsonobject formatted as hex string\n    example: 507f1f77bcf86cd799439011\n    nullable: true\n    type: string\n  name:\n    type: string\n  timestamp:\n    format: int64\n    nullable: true\n    type: integer\n  version:\n    type: string\nrequired:\n- name\n- version\n- favorite\n- description\ntype: object\nxml:\n  name: MlModelOnlyInfo\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertMlmodel(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-mlmodel",
			Short:   "update-mlmodel",
			Long:    cli.Markdown("Updates a machine learning model\n## Request Schema (text/json)\n\nproperties:\n  className:\n    nullable: true\n    type: string\n  description:\n    type: string\n  favorite:\n    type: boolean\n  modelFileId:\n    description: Should be a valid mongodb bsonobject formatted as hex string\n    example: 507f1f77bcf86cd799439011\n    nullable: true\n    type: string\n  name:\n    type: string\n  timestamp:\n    format: int64\n    nullable: true\n    type: integer\n  version:\n    type: string\nrequired:\n- name\n- version\n- favorite\n- description\ntype: object\nxml:\n  name: MlModelOnlyInfo\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdateMlmodel(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-mlmodel mlmodelname mlmodelversion",
			Short:   "delete-mlmodel",
			Long:    cli.Markdown("Delete a Machine learning model"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeleteMlmodel(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-mlmodel mlmodelname mlmodelversion",
			Short:   "get-mlmodel",
			Long:    cli.Markdown("Retrieves data on a specific Machine Learning model"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetMlmodel(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-pipegraph",
			Short:   "list-pipegraph",
			Long:    cli.Markdown("Lists all pipegraphs"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListPipegraph(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insert-pipegraph",
			Short:   "insert-pipegraph",
			Long:    cli.Markdown("Inserts a pipegraph\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  dashboard:\n    $ref: '#/components/schemas/DashboardModel'\n  description:\n    type: string\n  isSystem:\n    type: boolean\n  legacyStreamingComponents:\n    items:\n      $ref: '#/components/schemas/LegacyStreamingETLModel'\n    type: array\n  name:\n    type: string\n  owner:\n    type: string\n  rtComponents:\n    items:\n      $ref: '#/components/schemas/RTModel'\n    type: array\n  structuredStreamingComponents:\n    items:\n      $ref: '#/components/schemas/StructuredStreamingETLModel'\n    type: array\nrequired:\n- name\n- description\n- owner\n- isSystem\n- creationTime\n- legacyStreamingComponents\n- structuredStreamingComponents\n- rtComponents\ntype: object\nxml:\n  name: PipegraphModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertPipegraph(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-pipegraph",
			Short:   "update-pipegraph",
			Long:    cli.Markdown("updateds a pipegraph\n## Request Schema (text/json)\n\nproperties:\n  creationTime:\n    format: int64\n    type: integer\n  dashboard:\n    $ref: '#/components/schemas/DashboardModel'\n  description:\n    type: string\n  isSystem:\n    type: boolean\n  legacyStreamingComponents:\n    items:\n      $ref: '#/components/schemas/LegacyStreamingETLModel'\n    type: array\n  name:\n    type: string\n  owner:\n    type: string\n  rtComponents:\n    items:\n      $ref: '#/components/schemas/RTModel'\n    type: array\n  structuredStreamingComponents:\n    items:\n      $ref: '#/components/schemas/StructuredStreamingETLModel'\n    type: array\nrequired:\n- name\n- description\n- owner\n- isSystem\n- creationTime\n- legacyStreamingComponents\n- structuredStreamingComponents\n- rtComponents\ntype: object\nxml:\n  name: PipegraphModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdatePipegraph(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-pipegraph pipegraphname",
			Short:   "delete-pipegraph",
			Long:    cli.Markdown("Deletes a pipegraph"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeletePipegraph(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-pipegraph-instance pipegraphname",
			Short:   "list-pipegraph-instance",
			Long:    cli.Markdown("List all instances of a pipegraph"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiListPipegraphInstance(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-pipegraph-instance pipegraphname instance",
			Short:   "get-pipegraph-instance",
			Long:    cli.Markdown("Retrieves a pipegraph instance"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetPipegraphInstance(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "start-pipegraph pipegraphname",
			Short:   "start-pipegraph",
			Long:    cli.Markdown("Starts a new instance of pipegraph"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStartPipegraph(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stop-pipegraph pipegraphname",
			Short:   "stop-pipegraph",
			Long:    cli.Markdown("Stops the running instance of a pipegrah"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStopPipegraph(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-producer",
			Short:   "get-producer",
			Long:    cli.Markdown("Retrieves all producers"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetProducer(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "insert-producer",
			Short:   "insert-producer",
			Long:    cli.Markdown("Inserts a producer\n## Request Schema (text/json)\n\nproperties:\n  className:\n    type: string\n  configuration:\n    nullable: true\n    type: string\n  isActive:\n    type: boolean\n  isRemote:\n    type: boolean\n  isSystem:\n    type: boolean\n  name:\n    type: string\n  topicName:\n    nullable: true\n    type: string\nrequired:\n- name\n- className\n- isActive\n- isRemote\n- isSystem\ntype: object\nxml:\n  name: ProducerModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiInsertProducer(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-producer",
			Short:   "update-producer",
			Long:    cli.Markdown("Updates a new producer\n## Request Schema (text/json)\n\nproperties:\n  className:\n    type: string\n  configuration:\n    nullable: true\n    type: string\n  isActive:\n    type: boolean\n  isRemote:\n    type: boolean\n  isSystem:\n    type: boolean\n  name:\n    type: string\n  topicName:\n    nullable: true\n    type: string\nrequired:\n- name\n- className\n- isActive\n- isRemote\n- isSystem\ntype: object\nxml:\n  name: ProducerModel\n  namespace: java://it.agilelab.bigdata.wasp.core.models\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("text/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiUpdateProducer(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-producer producername",
			Short:   "delete-producer",
			Long:    cli.Markdown("Deletes a producer"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiDeleteProducer(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "start-producer producername",
			Short:   "start-producer",
			Long:    cli.Markdown("Start a producer"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStartProducer(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stop-producer producername",
			Short:   "stop-producer",
			Long:    cli.Markdown("Stop a producerj"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := WaspOpenapiStopProducer(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-raw",
			Short:   "list-raw",
			Long:    cli.Markdown("Retrieves all models used to write or read from Raw Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListRaw(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-raw modelname",
			Short:   "get-raw",
			Long:    cli.Markdown("Retrieves the model used to write or read from Raw Stores"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetRaw(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stats starttimestamp endtimestamp size",
			Short:   "stats",
			Long:    cli.Markdown("Retrieve stats about logs, events and metrics"),
			Example: examples,
			Args:    cobra.MinimumNArgs(3),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiStats(args[0], args[1], args[2], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-telemetry-metric search source size",
			Short:   "list-telemetry-metric",
			Long:    cli.Markdown("List top telemetry metrics for source matching search"),
			Example: examples,
			Args:    cobra.MinimumNArgs(3),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListTelemetryMetric(args[0], args[1], args[2], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-telemetry-series metric source size starttimestamp endtimestamp aggregate",
			Short:   "get-telemetry-series",
			Long:    cli.Markdown("Retrieves series data pre aggregated by the server for display"),
			Example: examples,
			Args:    cobra.MinimumNArgs(6),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetTelemetrySeries(args[0], args[1], args[2], args[3], args[4], args[5], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-telemetry-source search size",
			Short:   "list-telemetry-source",
			Long:    cli.Markdown("List top telemetry sources matching search"),
			Example: examples,
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListTelemetrySource(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-topic",
			Short:   "list-topic",
			Long:    cli.Markdown("Lists all models used to write or read from message queues"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiListTopic(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-topic topicname",
			Short:   "get-topic",
			Long:    cli.Markdown("Retrieves the model used to write or read from message queues"),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := WaspOpenapiGetTopic(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("pretty", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

}
